-- Create cron job log table
CREATE TABLE public.cron_job_logs (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    job_name TEXT NOT NULL,
    status TEXT NOT NULL CHECK (status IN ('started', 'completed', 'failed')),
    start_time TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT TIMEZONE('utc'::text, NOW()),
    end_time TIMESTAMP WITH TIME ZONE NULL,
    duration_seconds INTEGER NULL,
    records_processed INTEGER NULL DEFAULT 0,
    employees_processed INTEGER NULL DEFAULT 0,
    error_message TEXT NULL,
    details JSONB NULL DEFAULT '{}'::jsonb,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT TIMEZONE('utc'::text, NOW()),
    CONSTRAINT cron_job_logs_pkey PRIMARY KEY (id)
) TABLESPACE pg_default;

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_cron_job_logs_job_name ON public.cron_job_logs USING btree (job_name) TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS idx_cron_job_logs_status ON public.cron_job_logs USING btree (status) TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS idx_cron_job_logs_start_time ON public.cron_job_logs USING btree (start_time) TABLESPACE pg_default;

-- Enhanced function with logging
CREATE OR REPLACE FUNCTION update_attendance_summaries_with_logging(p_employee_id TEXT DEFAULT NULL)
RETURNS JSONB AS $$
DECLARE
    v_log_id BIGINT;
    v_start_time TIMESTAMP WITH TIME ZONE;
    v_end_time TIMESTAMP WITH TIME ZONE;
    v_employee_count INTEGER := 0;
    v_record_count INTEGER := 0;
    rec RECORD;
    v_error_msg TEXT;
    v_job_name TEXT := 'attendance_summaries_update';
    v_result JSONB;
    employee_cursor CURSOR FOR
        SELECT DISTINCT employee_id 
        FROM public.attendance_records 
        WHERE (p_employee_id IS NULL OR employee_id = p_employee_id);
BEGIN
    v_start_time := TIMEZONE('utc'::text, NOW());
    
    -- If specific employee provided, adjust job name
    IF p_employee_id IS NOT NULL THEN
        v_job_name := v_job_name || '_' || p_employee_id;
    END IF;
    
    -- Insert initial log entry
    INSERT INTO public.cron_job_logs (
        job_name, 
        status, 
        start_time,
        details
    ) VALUES (
        v_job_name,
        'started',
        v_start_time,
        JSONB_BUILD_OBJECT(
            'employee_id', p_employee_id,
            'trigger_type', CASE WHEN p_employee_id IS NULL THEN 'bulk' ELSE 'single' END
        )
    ) RETURNING id INTO v_log_id;
    
    BEGIN
        -- Process employees and count records
        FOR rec IN employee_cursor LOOP
            PERFORM update_employee_monthly_summaries(rec.employee_id);
            v_employee_count := v_employee_count + 1;
            
            -- Count attendance records for this employee
            SELECT COUNT(*) INTO v_record_count 
            FROM public.attendance_records 
            WHERE employee_id = rec.employee_id;
        END LOOP;
        
        v_end_time := TIMEZONE('utc'::text, NOW());
        
        -- Update log with success
        UPDATE public.cron_job_logs 
        SET 
            status = 'completed',
            end_time = v_end_time,
            duration_seconds = EXTRACT(EPOCH FROM (v_end_time - v_start_time))::INTEGER,
            employees_processed = v_employee_count,
            records_processed = v_record_count,
            details = details || JSONB_BUILD_OBJECT(
                'completion_time', v_end_time,
                'success', true
            )
        WHERE id = v_log_id;
        
        -- Return success result
        v_result := JSONB_BUILD_OBJECT(
            'success', true,
            'log_id', v_log_id,
            'employees_processed', v_employee_count,
            'records_processed', v_record_count,
            'duration_seconds', EXTRACT(EPOCH FROM (v_end_time - v_start_time))::INTEGER,
            'message', 'Attendance summaries updated successfully'
        );
        
    EXCEPTION WHEN others THEN
        v_error_msg := SQLERRM;
        v_end_time := TIMEZONE('utc'::text, NOW());
        
        -- Update log with failure
        UPDATE public.cron_job_logs 
        SET 
            status = 'failed',
            end_time = v_end_time,
            duration_seconds = EXTRACT(EPOCH FROM (v_end_time - v_start_time))::INTEGER,
            employees_processed = v_employee_count,
            records_processed = v_record_count,
            error_message = v_error_msg,
            details = details || JSONB_BUILD_OBJECT(
                'error_time', v_end_time,
                'success', false,
                'error_detail', v_error_msg
            )
        WHERE id = v_log_id;
        
        -- Return error result
        v_result := JSONB_BUILD_OBJECT(
            'success', false,
            'log_id', v_log_id,
            'employees_processed', v_employee_count,
            'records_processed', v_record_count,
            'duration_seconds', EXTRACT(EPOCH FROM (v_end_time - v_start_time))::INTEGER,
            'error', v_error_msg,
            'message', 'Attendance summaries update failed'
        );
        
        -- Re-raise the exception
        RAISE;
    END;
    
    RETURN v_result;
END;
$$ LANGUAGE plpgsql;

-- Function to clean up old logs (useful for maintenance)
CREATE OR REPLACE FUNCTION cleanup_cron_job_logs(days_to_keep INTEGER DEFAULT 30)
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM public.cron_job_logs 
    WHERE created_at < (CURRENT_DATE - INTERVAL '1 day' * days_to_keep);
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    
    INSERT INTO public.cron_job_logs (
        job_name,
        status,
        start_time,
        end_time,
        records_processed,
        details
    ) VALUES (
        'log_cleanup',
        'completed',
        TIMEZONE('utc'::text, NOW()),
        TIMEZONE('utc'::text, NOW()),
        deleted_count,
        JSONB_BUILD_OBJECT(
            'days_kept', days_to_keep,
            'records_deleted', deleted_count,
            'cleanup_date', CURRENT_DATE
        )
    );
    
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- View for easy monitoring of cron job performance
CREATE OR REPLACE VIEW cron_job_logs_summary with (security_invoker = on) 
AS SELECT 
    job_name,
    COUNT(*) as total_runs,
    COUNT(*) FILTER (WHERE status = 'completed') as successful_runs,
    COUNT(*) FILTER (WHERE status = 'failed') as failed_runs,
    ROUND(
        COUNT(*) FILTER (WHERE status = 'completed') * 100.0 / COUNT(*), 2
    ) as success_rate_percent,
    AVG(duration_seconds) FILTER (WHERE status = 'completed') as avg_duration_seconds,
    MAX(start_time) as last_run,
    MAX(start_time) FILTER (WHERE status = 'completed') as last_successful_run,
    MAX(start_time) FILTER (WHERE status = 'failed') as last_failed_run
FROM public.cron_job_logs
GROUP BY job_name
ORDER BY last_run DESC;