create type public.app_permission as enum ('users.select', 'users.delete', 'attendance_records.select', 'attendance_records.delete', 'attendance_summaries.select', 'attendance_summaries.delete');
create type public.app_roles as enum ('admin');
create type public.work_mode as enum ('office', 'home');

create table public.users (
  id uuid references auth.users primary key,
  full_name text not null,
  employee_id text not null unique,
  email text not null unique,
  department text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  update_at timestamp with time zone default timezone('utc'::text, null)
);

create index idx_employee_id on public.users(employee_id);
comment on table public.users is 'Profile data for each user';
comment on column public.users.id is 'References supabase auth users';

create table public.attendance_records (
  id bigint generated by default as identity primary key,
  employee_id text references public.users(employee_id),
  work_date date,
  check_in timestamp,
  lunch_out timestamp,
  lunch_in timestamp,
  check_out timestamp,
  work_mode work_mode,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, null)
);

create index idx_employee_id_records on public.attendance_records(employee_id);
create index idx_work_date on public.attendance_records(work_date);
comment on table public.attendance_records is 'Records of employee daily attendance';

create table attendance_summaries (
  id bigint generated by default as identity primary key,
  employee_id text references public.users(employee_id),
  year integer not null,
  month integer not null,
  total_days integer not null,
  total_hours integer not null,
  avg_daily_hours smallint not null,
  generated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create index idx_employee_id_summaries on attendance_summaries(employee_id);
comment on table public.attendance_summaries is 'Summary of recorded employee attendance';

create table public.user_roles (
  id bigint generated by default as identity primary key,
  user_id uuid references public.users on delete cascade not null,
  role app_roles not null,
  unique (user_id, role)
);

comment on table public.user_roles is 'Application roles for each user';

create table public.role_permissions (
  id bigint generated by default as identity primary key,
  role app_roles not null,
  permission app_permission not null,
  unique (role, permission)
);

comment on table public.role_permissions is 'Application permissions for each user';

create function public.authorize (
  requested_permission app_permission
)
returns boolean as $$
declare bind_permissions int;
begin
 select count(*)
 from public.role_permissions
 where role_permissions.permission = authorize.requested_permission
  and role_permissions.role = (auth.jwt() ->> 'user_role')::public.app_roles
 into bind_permissions;

 return bind_permissions > 0;
end;
$$ language plpgsql security definer set search_path = public;

-- set RLS policies
alter table public.users enable row level security;
alter table public.attendance_records enable row level security;
alter table public.attendance_summaries enable row level security;
alter table public.user_roles enable row level security;
alter table public.role_permissions enable row level security;
create policy "Allow individual read access" on public.users for select using ( auth.uid() = id );
create policy "Allow individual insert access" on public.users for insert with check ( auth.uid() = id );
create policy "Allow individual update access" on public.users for update using ( auth.uid() = id );
create policy "Allow individual read access" on public.attendance_records for select using ( employee_id = (select employee_id from public.users where id = auth.uid()) );
create policy "Allow individual insert access" on public.attendance_records for insert with check ( employee_id = (select employee_id from public.users where id = auth.uid())  );
create policy "Allow individual update access" on public.attendance_records for update using ( employee_id = (select employee_id from public.users where id = auth.uid()) );
create policy "Allow individual read access" on public.attendance_summaries for select using ( employee_id = (select employee_id from public.users where id = auth.uid()) );
create policy "Allow individual insert access" on public.attendance_summaries for insert with check ( employee_id = (select employee_id from public.users where id = auth.uid())  );
create policy "Allow authorized read access on users" on public.users for select using ( authorize('users.select') );
create policy "Allow authorized delete access on users" on public.users for delete using ( authorize('users.delete') );
create policy "Allow authorized read access on records" on public.attendance_records for select using ( authorize('attendance_records.select') );
create policy "Allow authorized delete access on records" on public.attendance_records for delete using ( authorize('attendance_records.delete') );
create policy "Allow authorized read access on summaries" on public.attendance_summaries for select using ( authorize('attendance_summaries.select') );
create policy "Allow authorized delete access on summaries" on public.attendance_summaries for delete using ( authorize('attendance_summaries.delete') );
create policy "Allow individual read access" on public.user_roles for select using ( auth.uid() = user_id );

-- send "previous data" on list_changes
alter table public.users replica identity full;
alter table public.attendance_records replica identity full;
alter table public.attendance_summaries replica identity full;

-- inserts a row into public.users and assigns roles
create function public.handle_new_user()
returns trigger as $$
declare is_admin boolean;
begin
  insert into public.users (id, fullname, employee_id, email, department)
  values (new.id, new.email);

  select count(*) = 1 from auth.users into is_admin;

  if position('+admin@' in new.email) > 0 then
    insert into public.user_roles (user_id, role) values (new.id, 'admin');
  end if;

  return new;
end;
$$ language plpgsql security definer set search_path = auth, public;

-- trigger the function every time a user is created
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

/**
 * HELPER FUNCTIONS
 * Create test user helper method.
 */
create or replace function public.create_user(
    email text
) returns uuid
    security definer
    set search_path = auth
as $$
  declare
  user_id uuid;
begin
  user_id := extensions.uuid_generate_v4();

  insert into auth.users (id, email)
    values (user_id, email)
    returning id into user_id;

    return user_id;
end;
$$ language plpgsql;